#include <stdio.h>
#include <unistd.h>

// 可以看到 , 相比于实验一 , 这次我们的代码少了 bingo 函数
// 但是我们最后达到的效果还是得到 宿主机 的 shell
// 那么我们应该怎么做呢 , 这里需要用到一种机制 : 栈内存代码执行漏洞
// 我们先来分析一下代码
int main(){
	char buffer[0x50] = {0}; // 定义一个 0x50 = 80 个字节的字符数组 , 并全部初始化为 0 
	/*
	 * 这次的程序和上次实验室相比 : 
	 *		1. 缺少了 bingo 函数
	 *		2. 定义的 buffer 数组长度变大
	 *		3. 使用 printf 函数将 buffer 数组的首地址打印出来了
	 *	这三个条件就是这次我们能溢出成功的保证
	 *	这次我们的思路是这样的
	 *	既然这次程序并没有给我们给出一个可以执行 /bin/sh 的 bingo 函数
	 *	那么我们就需要自己用汇编语言编写一个调用 /bin/sh 的程序 , 将这个程序汇编以后得到的机器码(注意必须得是相同平台 , 否则机器码不会正常执行)通过 read 函数写入到内存中
	 *	然后由于 read 函数并不检查 buffer 数组的边界
	 *	因此我们还是可以溢出来覆盖掉 main 函数的返回地址
	 *	因此我们就需要将机器码先写入到 buffer 中 , 然后再填充一些无用的字符直到 main 的返回地址处 , 当程序执行到这里的时候 , 为了能让我们用汇编编译的机器码成功执行 , 我们就需要让汇编机器码的地址覆盖 main 的返回地址
	 *	这就需要我们获取 buffer 的首地址 , 计算机器码的偏移(当然 , 如果汇编机器码是从 buffer 的第一个字节开始写入内存的话 , 那么偏移就是 0 , 那么地址就是 buffer 的首地址 , 事实上 , 机器码要越短小精悍越好 , 因为 buffer 的长度可能并不足以储存机器码 , 也就是说 buffer 的地址是非常宝贵的 , 因此最好从 buffer 的首字节开始写入) , 然后将机器码的首地址覆盖到 main 的返回地址 , 然后就可以成功执行 可以运行/bin/sh的机器码
	 *	这样我们就成功获取到了目标机器的 shell
	 */
	printf("&buffer = %p\n", &buffer); // 打印字符数组在内存(栈段)中的地址
	fflush(stdout); // 刷新缓冲区
	read(0, buffer, 0xFF); // 使用 read 函数将缓冲区中的 0xFF 字节长度的数据读取到 buffer 数组中 , 以换行符结束
	printf("Content of buffer : %s\n", buffer); // 打印 buffer 的值
	return 0; // 主函数返回
}
