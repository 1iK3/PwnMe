#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

// 栈溢出后执行的函数
void bingo(){
	system("/bin/sh"); // 调用 system 函数启动 /bin/sh 来获取 shell
}

int main(){
	char buffer[36] = {0}; // 定义 36 个字符(字节)长度的字符数组 , 并全部初始化为 0
	puts("Tell my why : ");
	/* 溢出漏洞产生的原因就是因为 read 函数并没有对 buffer 数组的范围进行检查 
	 * 如果我们向标准输入流中输入了超出 buffer 范围 (36个字节) 的数据 , 那么写操作并不会停止 , 而是会继续向内存中写入数据 , 而这些数据就是由我们控制的
	 * 我们知道 , buffer 数组是保存在内存中的栈段中的 , 而 main 函数的返回地址也是保存在栈段中的
	 * 因此 , 我们只需要控制写入的数据 , 将 main 函数的返回地址覆盖
	 * 这样 , 在主函数执行结束后 , 会 pop 栈中保存的主函数的返回地址 (事实上已经被我们写入的数据覆盖) 到 eip 寄存器中
	 * cpu 就会不会认为程序已经结束 , 而是继续根据 eip 寄存器指向的内存取指令执行 , 这样我们就达到了可以任意控制程序流程的目的
	 * 因此 , 我们为了能获取一个 shell , 我们需要将主函数的返回地址覆盖为 bingo 函数的地址
	 * 然后程序继续执行之后遇到 return 0 就会直接跳转到 bingo 函数 , 从而运行 /bin/sh , 我们就可以得到目标主机的 shell
	 * 由于时间关系 , 这里所有的操作都在本机进行 , 远程操作也是同样的道理 , 因此不再赘述
	 */
	read(0, buffer, 0xFF); // 使用 read 函数将标准输入流中的数据复制到 buffer 字符数组
	printf("Good boy : %s\n", buffer); // 打印字符数组的长度
	return 0; // 主函数返回
}
